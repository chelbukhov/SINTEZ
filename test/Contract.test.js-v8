const assert = require ('assert');              // утверждения
const ganache = require ('ganache-cli');        // тестовая сеть
const Web3 = require ('web3');                  // библиотека для подключения к ефириуму
const web3 = new Web3(ganache.provider());      // настройка провайдера


require('events').EventEmitter.defaultMaxListeners = 0;


const compiledContract = require('../build/Crowdsale.json');

let accounts;
let contractAddress;
//console.log(Date());



describe('Серия тестов для пути развития - софткап не пройден => refunding...', () => {

    it('Разворачиваем контракт для тестирования...', async () => {

        accounts = await web3.eth.getAccounts();
        //    console.log(accounts);
        //    console.log(await web3.eth.getBalance(accounts[0]));
            // получаем контракт из скомпилированного ранее файла .json
        // разворачиваем его в тестовой сети и отправляем транзакцию
        contract = await new web3.eth.Contract(JSON.parse(compiledContract.interface))
            .deploy({ data: compiledContract.bytecode })
            .send({ from: accounts[0], gas: '6000000'});
    });
    

    it('Адрес контракта...', async () => {
        console.log(await contract.options.address);
    });

    it('Проверка баланса контракта...', async () => {
        let cBalance = web3.utils.fromWei(await contract.methods.getBalance().call(), 'ether');
        console.log("Balance of contract in Ether: ", cBalance);
        assert(cBalance == 0);
    });

    it('Проверка собственника контракта...', async () => {
        const cOwner = await contract.methods.owner().call();
        assert.equal(accounts[0], cOwner);
    });

    it('Получаем стадию контракта, по умолчанию это init', async () => {
        const myState = await contract.methods.currentState().call({
            from: accounts[3],
            gas: "1000000"
        });
        assert(myState == 0);
    });

    it('Запускаем Pre-Sale от постороннего пользователя - revert', async () => {
        // правильным завершением этого теста является наличие ошибки
        try {
            await contract.methods.startPreSale().send({
                from: accounts[3],
                gas: "1000000"
            });
            assert(false);    
        } catch (error) {
            assert(error);
        }
    });

    it('Снова получаем стадию контракта, все еще init', async () => {
        const myState = await contract.methods.currentState().call({
            from: accounts[3],
            gas: "1000000"
        });
        assert(myState == 0);
    });

    it('Запускаем Pre-Sale от собственника - ОК', async () => {
        try {
            await contract.methods.startPreSale().send({
                from: accounts[0],
                gas: "1000000"
            });
            assert(true);    
        } catch (error) {
            assert(false);
        }

    });

    it('Проверяем state в отдельном блоке It ', async () => {
        const myState2 = await contract.methods.currentState().call({
            from: accounts[0],
            gas: "1000000"
        });
        assert(myState2 == 1);
    });

    it('Проверяем расчет бонуса для Pre-Sale...', async () => {
        const bonusPreSale = await contract.methods.calcBonus().call({
            from: accounts[0],
            gas: "1000000"
        });
        assert(bonusPreSale == 20);
    });

    it('Переводим 10 эфиров на контракт - должен отбить, меньше минимума-20 эфиров', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[0],
                    value: 10*10**18,
                    gas: '1000000'
                });
            assert(false);
        } catch (error) {
            assert(error);
        }
    });
    
    it('Проверка баланса контракта - все еще должен быть ноль...', async () => {
        let cBalance = web3.utils.fromWei(await contract.methods.getBalance().call(), 'ether');
        assert(cBalance == 0);
    });

    it('Переводим 20 эфиров на контракт - должен принять...', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[0],
                    value: 20*10**18,
                    gas: '1000000'
                });
            assert(true);
        } catch (error) {
            assert(false);
            console.log(error);
        }
    });
    
    it('Проверка баланса контракта на наличие 20 эфиров...', async () => {
        let cBalance = web3.utils.fromWei(await contract.methods.getBalance().call(), 'ether');
        assert(cBalance == 20);
    });

    it('Проверка поступления токенов на счет отправителя с учетом бонуса = 120 000...', async () => {
        let tokenBalance = await contract.methods.getBalanceTokens(accounts[0]).call();
        assert(tokenBalance == 120000 * (10**18));
    });

    it('Проверка баланса на accounts[0] эфиров...', async () => {
        const initialBalance = await web3.eth.getBalance(accounts[0]);
        assert(initialBalance > 0);
        //console.log("Balance of accounts[0]: ", initialBalance / (10**18));
    });

    it('Переводим 80 эфиров на контракт - проверка выполнения RPESALE_TOKEN_SUPPLY_LIMIT = 100 эфиров без учета бонусов...', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[1],
                    value: 80*10**18,
                    gas: '1000000'
                });
            assert(true);
        } catch (error) {
            assert(false);
            console.log(error);
        }
    });

    it('Проверка баланса контракта - должно быть 100 эфиров...', async () => {
        let cBalance = web3.utils.fromWei(await contract.methods.getBalance().call(), 'ether');
        assert(cBalance == 100);
        //console.log("Balance of contract", cBalance);
    });

    it('Проверка проданных токенов - должно быть 600тыс. (100 эфиров * 5000 + 20%) ...', async () => {
        let tokenBalance = await contract.methods.soldTokens().call();
        assert(tokenBalance == 600000 * (10 ** 18));
    });

    it('Переводим 5 эфиров на контракт - проверка переполнения RPESALE_TOKEN_SUPPLY_LIMIT = 500 тыс...', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[1],
                    value: 5*10**18,
                    gas: '1000000'
                });
            assert(false);
        } catch (error) {
            assert(error);
        }
    });

    it('Проверка баланса контракта - должно быть 100 эфиров...', async () => {
        let cBalance = web3.utils.fromWei(await contract.methods.getBalance().call(), 'ether');
        assert(cBalance == 100);
    });


    it('Запускаем Pre-ICO от собственника - revert (слишком рано)', async () => {
        try {
            await contract.methods.startPreICO().send({
                from: accounts[0],
                gas: "1000000"
            });
            assert(false);    
        } catch (error) {
            assert(error);
        }
    });

    // увеличиваем время в ganache-cli на 10 дней
    it('increase time for 10 days', async () => {
        const myVal = await new Promise((resolve, reject) =>
        web3.currentProvider.sendAsync({
            jsonrpc: "2.0",
            method: "evm_increaseTime",
            params: [60 * 60 * 24 * 10],
            id: new Date().getTime()
        }, (error, result) => error ? reject(error) : resolve(result.result))
    );
    });

    it('Запускаем Pre-ICO от собственника через 10 дней...', async () => {
        try {
            await contract.methods.startPreICO().send({
                from: accounts[0],
                gas: "1000000"
            });
            assert(true);    
        } catch (error) {
            assert(false);
            console.log(error);
        }
    });

    it('Переводим 40 эфиров на контракт - выполнения ограничения первого дня - макс 20 эфиров...', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[2],
                    value: 40*10**18,
                    gas: '1000000'
                });
            assert(false);
        } catch (error) {
            assert(error);
        }
    });

    it('Переводим 20 эфиров на контракт - должен принять...', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[2],
                    value: 20*10**18,
                    gas: '1000000'
                });
            assert(true);
        } catch (error) {
            assert(false);
            console.log(error);
        }
    });

    it('Проверка баланса контракта - должно быть 120 эфиров...', async () => {
        let cBalance = web3.utils.fromWei(await contract.methods.getBalance().call(), 'ether');
        assert(cBalance == 120);
        //console.log("Balance of contract", cBalance);
    });

    // увеличиваем время в ganache-cli на 1 день
    it('increase time for 1 days', async () => {
        const myVal = await new Promise((resolve, reject) =>
        web3.currentProvider.sendAsync({
            jsonrpc: "2.0",
            method: "evm_increaseTime",
            params: [60 * 60 * 24],
            id: new Date().getTime()
        }, (error, result) => error ? reject(error) : resolve(result.result))
        );
    });

    it('Переводим 40 эфиров на контракт - должен принять...', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[2],
                    value: 40*10**18,
                    gas: '1000000'
                });
            assert(true);
        } catch (error) {
            assert(false);
            console.log(error);
        }
    });

    it('Проверка баланса контракта - должно быть 160 эфиров...', async () => {
        let cBalance = web3.utils.fromWei(await contract.methods.getBalance().call(), 'ether');
        assert(cBalance == 160);
        //console.log("Balance of contract", cBalance);
    });

    it('Проверка проданных токенов - должгл быть 930тыс. (100 эфиров * 5000 + 20%  +   60 * 5000 + 10% = 930 000) ...', async () => {
        let tokenBalance = await contract.methods.soldTokens().call();
        assert(tokenBalance == 930000 * (10 ** 18));
        //console.log(tokenBalance);
    });

    it('Переводим 20 эфиров на контракт - должен принять...', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[2],
                    value: 20*10**18,
                    gas: '1000000'
                });
            assert(true);
        } catch (error) {
            assert(false);
            console.log(error);
        }
    });

    it('Проверка проданных токенов - должгл быть 1040тыс. (100 эфиров * 5000 + 20%  +   80 * 5000 + 10% = 1040 000) ...', async () => {
        let tokenBalance = await contract.methods.soldTokens().call();
        assert(tokenBalance == 1040000 * (10 ** 18));
        //console.log(tokenBalance);
    });

    it('Переводим 1 эфир на контракт - должен отбить - превышение RPEICO_TOKEN_SUPPLY_LIMIT...', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[2],
                    value: 20*10**18,
                    gas: '1000000'
                });
            assert(false);
        } catch (error) {
            assert(error);
        }
    });

    it('Запускаем CrowdSale от собственника через 1 дней - слишком рано...', async () => {
        try {
            await contract.methods.startCrowdSale().send({
                from: accounts[0],
                gas: "1000000"
            });
            assert(false);    
        } catch (error) {
            assert(error);
        }
    });

    // увеличиваем время в ganache-cli на 14 дней
    it('increase time for 14 days', async () => {
        const myVal = await new Promise((resolve, reject) =>
        web3.currentProvider.sendAsync({
            jsonrpc: "2.0",
            method: "evm_increaseTime",
            params: [60 * 60 * 24 * 14],
            id: new Date().getTime()
        }, (error, result) => error ? reject(error) : resolve(result.result))
        );
    });

    it('Запускаем CrowdSale от собственника через 15 дней...', async () => {
        try {
            await contract.methods.startCrowdSale().send({
                from: accounts[0],
                gas: "1000000"
            });
            assert(true);    
        } catch (error) {
            assert(false);
        }
    });

    it('Переводим 20 эфиров на контракт - должен принять...', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[4],
                    value: 20*10**18,
                    gas: '1000000'
                });
            assert(true);
        } catch (error) {
            assert(false);
            console.log(error);
        }
    });

    it('Проверка баланса контракта - должно быть 200 эфиров...', async () => {
        let cBalance = web3.utils.fromWei(await contract.methods.getBalance().call(), 'ether');
        assert(cBalance == 200);
        //console.log("Balance of contract", cBalance);
    });

    it('Проверка проданных токенов - должгл быть 1140тыс. (100 эфиров * 5000 + 20%  +   80 * 5000 + 10%  + 20 * 5000  = 1140) ...', async () => {
        let tokenBalance = await contract.methods.soldTokens().call();
        assert(tokenBalance == 1140000 * (10 ** 18));
        //console.log(tokenBalance);
    });

    it('Проверка токенов на счете контракта - должно быть 398 860 000...', async () => {
        let tokenBalance = await contract.methods.getBalanceTokens(contract.options.address).call();
        assert(tokenBalance == 398860000 * (10**18));
        //console.log(tokenBalance);
    });

    it('Возвращаем токены с дополнительного адреса...', async () => {
        try {
            await contract.methods.returnTokensFromHoldAdditionalAddress(1000000000 / 100 * 8).send({
                from: accounts[0],
                gas: '1000000'
            });
            assert(true);    
        } catch (error) {
            assert(false);
        }
    });

    it('Проверка токенов на счете контракта - должно быть 478 860 000...', async () => {
        let tokenBalance = await contract.methods.getBalanceTokens(contract.options.address).call();
        assert(tokenBalance == 478860000 * (10**18));
        //console.log(tokenBalance);
    });    

    it('Возвращаем токены с адреса адвизоров - должен отбить, слишком рано...', async () => {
        try {
            await contract.methods.returnTokensFromHoldAdvisorsAddress(1000000000 / 100).send({
                from: accounts[0],
                gas: '1000000'
            });
            assert(false);    
        } catch (error) {
            assert(error);
        }
    });

    // увеличиваем время в ganache-cli на 15 дней
    it('increase time for 15 days', async () => {
        const myVal = await new Promise((resolve, reject) =>
        web3.currentProvider.sendAsync({
            jsonrpc: "2.0",
            method: "evm_increaseTime",
            params: [60 * 60 * 24 * 15],
            id: new Date().getTime()
        }, (error, result) => error ? reject(error) : resolve(result.result))
        );
    });

    it('Возвращаем токены с адреса адвизоров - должен вернуть...', async () => {
        try {
            await contract.methods.returnTokensFromHoldAdvisorsAddress(1000000000 / 100).send({
                from: accounts[0],
                gas: '1000000'
            });
            assert(true);    
        } catch (error) {
            assert(false);
        }
    });

    it('Проверка токенов на счете контракта - должно быть 488 860 000...', async () => {
        let tokenBalance = await contract.methods.getBalanceTokens(contract.options.address).call();
        assert(tokenBalance == 488860000 * (10**18));
        //console.log(tokenBalance);
    });  

    it('Возвращаем токены с адреса баунти - должен вернуть...', async () => {
        try {
            await contract.methods.returnTokensFromHoldBountyAddress(1000000000 / 100).send({
                from: accounts[0],
                gas: '1000000'
            });
            assert(true);    
        } catch (error) {
            assert(false);
        }
    });


    it('Проверка токенов на счете контракта - должно быть 498 860 000...', async () => {
        let tokenBalance = await contract.methods.getBalanceTokens(contract.options.address).call();
        assert(tokenBalance == 498860000 * (10**18));
        //console.log(tokenBalance);
    });


    it('Возвращаем токены с адреса проекта - должен отбить, слишком рано...', async () => {
        try {
            await contract.methods.returnTokensFromHoldProgectAddress(1000000000 / 2).send({
                from: accounts[0],
                gas: '1000000'
            });
            assert(false);    
        } catch (error) {
            assert(error);
        }
    });

    // увеличиваем время в ganache-cli на 324 дня
    it('increase time for 324 days', async () => {
        const myVal = await new Promise((resolve, reject) =>
        web3.currentProvider.sendAsync({
            jsonrpc: "2.0",
            method: "evm_increaseTime",
            params: [60 * 60 * 24 * 324],
            id: new Date().getTime()
        }, (error, result) => error ? reject(error) : resolve(result.result))
        );
    });

    it('Возвращаем токены с адреса проекта - должен отбить, слишком рано...', async () => {
        try {
            await contract.methods.returnTokensFromHoldProgectAddress(1000000000 / 2).send({
                from: accounts[0],
                gas: '1000000'
            });
            assert(false);    
        } catch (error) {
            assert(error);
        }
    });

    it('increase time for 1 days', async () => {
        const myVal = await new Promise((resolve, reject) =>
        web3.currentProvider.sendAsync({
            jsonrpc: "2.0",
            method: "evm_increaseTime",
            params: [60 * 60 * 24 * 1],
            id: new Date().getTime()
        }, (error, result) => error ? reject(error) : resolve(result.result))
        );
    });

    it('Возвращаем токены с адреса проекта - должен вернуть (прошло 365 дней)...', async () => {
        try {
            await contract.methods.returnTokensFromHoldProgectAddress(1000000000 / 2).send({
                from: accounts[0],
                gas: '1000000'
            });
            assert(true);    
        } catch (error) {
            assert(false);
        }
    });

    it('Проверка токенов на счете контракта - должно быть 998 860 000...', async () => {
        let tokenBalance = await contract.methods.getBalanceTokens(contract.options.address).call();
        assert(tokenBalance == 998860000 * (10**18));
        //console.log(tokenBalance);
    });

    it('Завершаем CrowdSale от собственника...', async () => {
        try {
            await contract.methods.finishCrowdSale().send({
                from: accounts[0],
                gas: "1000000"
            });
            assert(true);    
        } catch (error) {
            assert(false);
        }
    });

    it('Получаем стадию контракта, должен быть Refunding, т.к SoftCap не набран...', async () => {
        const myState = await contract.methods.currentState().call({
            from: accounts[3],
            gas: "1000000"
        });
        assert(myState ==4 );
        //console.log(myState);
    });

    it('Проверка токенов на счете account[2] ...', async () => {
        let tokenBalance = await contract.methods.getBalanceTokens(accounts[2]).call();
        assert(tokenBalance == 440000 * (10**18));
        //console.log(tokenBalance);
    });   
    
    it('Проверка баланса контракта - должно быть 200 эфиров...', async () => {
        let cBalance = web3.utils.fromWei(await contract.methods.getBalance().call(), 'ether');
        assert(cBalance == 200);
        //console.log("Balance of contract", cBalance);
    });

    it('Проверка баланса на accounts[2] = 20 эфиров...', async () => {
        const initialBalance = await web3.eth.getBalance(accounts[2]);
        assert(initialBalance > 19);
        console.log("Balance of accounts[2]: ", initialBalance / (10**18));
    });

    it('Возвращаем средства на account[2]...', async () => {
        try {
            await contract.methods.refund().send({
                from: accounts[2],
                gas: "1000000"
            });
            assert(true);    
        } catch (error) {
            assert(false);
        }
    });

    it('Проверка баланса на accounts[2] = 100 эфиров...', async () => {
        const initialBalance = await web3.eth.getBalance(accounts[2]);
        assert(initialBalance > 99);
        console.log("Balance of accounts[2]: ", initialBalance / (10**18));
    });

    it('Повторно!!! Возвращаем средства на account[2] - функция работает, но баланс уже не добавляется...', async () => {
        try {
            await contract.methods.refund().send({
                from: accounts[2],
                gas: "1000000"
            });
            assert(true);    
        } catch (error) {
            assert(false);
        }
    });

    it('Проверка баланса на accounts[2] = 100 эфиров...', async () => {
        const initialBalance = await web3.eth.getBalance(accounts[2]);
        assert(initialBalance > 99);
        console.log("Balance of accounts[2]: ", initialBalance / (10**18));
    });

    it('Проверка баланса контракта - должно быть 120 эфиров...', async () => {
        let cBalance = web3.utils.fromWei(await contract.methods.getBalance().call(), 'ether');
        assert(cBalance == 120);
        //console.log("Balance of contract", cBalance);
    }); 

});












describe('Серия тестов для пути развития - софткап пройден => WorkTime...', () => {

    it('Разворачиваем контракт для тестирования...', async () => {

        accounts = await web3.eth.getAccounts();
        //    console.log(accounts);
        //    console.log(await web3.eth.getBalance(accounts[0]));
            // получаем контракт из скомпилированного ранее файла .json
        // разворачиваем его в тестовой сети и отправляем транзакцию
        contract = await new web3.eth.Contract(JSON.parse(compiledContract.interface))
            .deploy({ data: compiledContract.bytecode })
            .send({ from: accounts[5], gas: '6000000'});
    });
    

    it('Адрес контракта...', async () => {
        console.log(await contract.options.address);
    });

    it('Проверка баланса контракта...', async () => {
        let cBalance = web3.utils.fromWei(await contract.methods.getBalance().call(), 'ether');
        console.log("Balance of contract in Ether: ", cBalance);
        assert(cBalance == 0);
    });

    it('Проверка собственника контракта...', async () => {
        const cOwner = await contract.methods.owner().call();
        assert.equal(accounts[5], cOwner);
    });

    it('Получаем стадию контракта, по умолчанию это init', async () => {
        const myState = await contract.methods.currentState().call({
            from: accounts[8],
            gas: "1000000"
        });
        assert(myState == 0);
    });

    it('Запускаем Pre-Sale от постороннего пользователя - revert', async () => {
        // правильным завершением этого теста является наличие ошибки
        try {
            await contract.methods.startPreSale().send({
                from: accounts[8],
                gas: "1000000"
            });
            assert(false);    
        } catch (error) {
            assert(error);
        }
    });

    it('Снова получаем стадию контракта, все еще init', async () => {
        const myState = await contract.methods.currentState().call({
            from: accounts[8],
            gas: "1000000"
        });
        assert(myState == 0);
    });

    it('Запускаем Pre-Sale от собственника - ОК', async () => {
        try {
            await contract.methods.startPreSale().send({
                from: accounts[5],
                gas: "1000000"
            });
            assert(true);    
        } catch (error) {
            assert(false);
        }

    });

    it('Проверяем state в отдельном блоке It ', async () => {
        const myState2 = await contract.methods.currentState().call({
            from: accounts[5],
            gas: "1000000"
        });
        assert(myState2 == 1);
    });

    it('Проверяем расчет бонуса для Pre-Sale...', async () => {
        const bonusPreSale = await contract.methods.calcBonus().call({
            from: accounts[5],
            gas: "1000000"
        });
        assert(bonusPreSale == 20);
    });

    it('Переводим 10 эфиров на контракт - должен отбить, меньше минимума-20 эфиров', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[5],
                    value: 10*10**18,
                    gas: '1000000'
                });
            assert(false);
        } catch (error) {
            assert(error);
        }
    });
    
    it('Проверка баланса контракта - все еще должен быть ноль...', async () => {
        let cBalance = web3.utils.fromWei(await contract.methods.getBalance().call(), 'ether');
        assert(cBalance == 0);
    });

    it('Переводим 20 эфиров на контракт - должен принять...', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[5],
                    value: 20*10**18,
                    gas: '1000000'
                });
            assert(true);
        } catch (error) {
            assert(false);
            console.log(error);
        }
    });
    
    it('Проверка баланса контракта на наличие 20 эфиров...', async () => {
        let cBalance = web3.utils.fromWei(await contract.methods.getBalance().call(), 'ether');
        assert(cBalance == 20);
    });

    it('Проверка поступления токенов на счет отправителя с учетом бонуса = 120 000...', async () => {
        let tokenBalance = await contract.methods.getBalanceTokens(accounts[5]).call();
        assert(tokenBalance == 120000 * (10**18));
    });

    it('Проверка баланса на accounts[0] эфиров...', async () => {
        const initialBalance = await web3.eth.getBalance(accounts[5]);
        assert(initialBalance > 0);
        //console.log("Balance of accounts[0]: ", initialBalance / (10**18));
    });

    it('Переводим 80 эфиров на контракт - проверка выполнения RPESALE_TOKEN_SUPPLY_LIMIT = 100 эфиров без учета бонусов...', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[6],
                    value: 80*10**18,
                    gas: '1000000'
                });
            assert(true);
        } catch (error) {
            assert(false);
            console.log(error);
        }
    });

    it('Проверка баланса контракта - должно быть 100 эфиров...', async () => {
        let cBalance = web3.utils.fromWei(await contract.methods.getBalance().call(), 'ether');
        assert(cBalance == 100);
        //console.log("Balance of contract", cBalance);
    });

    it('Проверка проданных токенов - должгл быть 600тыс. (100 эфиров * 5000 + 20%) ...', async () => {
        let tokenBalance = await contract.methods.soldTokens().call();
        assert(tokenBalance == 600000 * (10 ** 18));
    });

    it('Переводим 5 эфиров на контракт - проверка переполнения RPESALE_TOKEN_SUPPLY_LIMIT = 500 тыс...', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[6],
                    value: 5*10**18,
                    gas: '1000000'
                });
            assert(false);
        } catch (error) {
            assert(error);
        }
    });

    it('Проверка баланса контракта - должно быть 100 эфиров...', async () => {
        let cBalance = web3.utils.fromWei(await contract.methods.getBalance().call(), 'ether');
        assert(cBalance == 100);
    });


    it('Запускаем Pre-ICO от собственника - revert (слишком рано)', async () => {
        try {
            await contract.methods.startPreICO().send({
                from: accounts[5],
                gas: "1000000"
            });
            assert(false);    
        } catch (error) {
            assert(error);
        }
    });

    // увеличиваем время в ganache-cli на 10 дней
    it('increase time for 10 days', async () => {
        const myVal = await new Promise((resolve, reject) =>
        web3.currentProvider.sendAsync({
            jsonrpc: "2.0",
            method: "evm_increaseTime",
            params: [60 * 60 * 24 * 10],
            id: new Date().getTime()
        }, (error, result) => error ? reject(error) : resolve(result.result))
    );
    });

    it('Запускаем Pre-ICO от собственника через 10 дней...', async () => {
        try {
            await contract.methods.startPreICO().send({
                from: accounts[5],
                gas: "1000000"
            });
            assert(true);    
        } catch (error) {
            assert(false);
            console.log(error);
        }
    });

    it('Переводим 40 эфиров на контракт - выполнения ограничения первого дня - макс 20 эфиров...', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[7],
                    value: 40*10**18,
                    gas: '1000000'
                });
            assert(false);
        } catch (error) {
            assert(error);
        }
    });

    it('Переводим 20 эфиров на контракт - должен принять...', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[7],
                    value: 20*10**18,
                    gas: '1000000'
                });
            assert(true);
        } catch (error) {
            assert(false);
            console.log(error);
        }
    });

    it('Проверка баланса контракта - должно быть 120 эфиров...', async () => {
        let cBalance = web3.utils.fromWei(await contract.methods.getBalance().call(), 'ether');
        assert(cBalance == 120);
        //console.log("Balance of contract", cBalance);
    });

    // увеличиваем время в ganache-cli на 1 день
    it('increase time for 1 days', async () => {
        const myVal = await new Promise((resolve, reject) =>
        web3.currentProvider.sendAsync({
            jsonrpc: "2.0",
            method: "evm_increaseTime",
            params: [60 * 60 * 24],
            id: new Date().getTime()
        }, (error, result) => error ? reject(error) : resolve(result.result))
        );
    });

    it('Переводим 40 эфиров на контракт - должен принять...', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[7],
                    value: 40*10**18,
                    gas: '1000000'
                });
            assert(true);
        } catch (error) {
            assert(false);
            console.log(error);
        }
    });

    it('Проверка баланса контракта - должно быть 160 эфиров...', async () => {
        let cBalance = web3.utils.fromWei(await contract.methods.getBalance().call(), 'ether');
        assert(cBalance == 160);
        //console.log("Balance of contract", cBalance);
    });

    it('Проверка проданных токенов - должгл быть 930тыс. (100 эфиров * 5000 + 20%  +   60 * 5000 + 10% = 930 000) ...', async () => {
        let tokenBalance = await contract.methods.soldTokens().call();
        assert(tokenBalance == 930000 * (10 ** 18));
        //console.log(tokenBalance);
    });

    it('Переводим 20 эфиров на контракт - должен принять...', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[7],
                    value: 20*10**18,
                    gas: '1000000'
                });
            assert(true);
        } catch (error) {
            assert(false);
            console.log(error);
        }
    });

    it('Проверка проданных токенов - должгл быть 1040тыс. (100 эфиров * 5000 + 20%  +   80 * 5000 + 10% = 1040 000) ...', async () => {
        let tokenBalance = await contract.methods.soldTokens().call();
        assert(tokenBalance == 1040000 * (10 ** 18));
        //console.log(tokenBalance);
    });

    it('Переводим 1 эфир на контракт - должен отбить - превышение RPEICO_TOKEN_SUPPLY_LIMIT...', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[7],
                    value: 20*10**18,
                    gas: '1000000'
                });
            assert(false);
        } catch (error) {
            assert(error);
        }
    });

    it('Запускаем CrowdSale от собственника через 1 дней - слишком рано...', async () => {
        try {
            await contract.methods.startCrowdSale().send({
                from: accounts[5],
                gas: "1000000"
            });
            assert(false);    
        } catch (error) {
            assert(error);
        }
    });

    // увеличиваем время в ganache-cli на 14 дней
    it('increase time for 14 days', async () => {
        const myVal = await new Promise((resolve, reject) =>
        web3.currentProvider.sendAsync({
            jsonrpc: "2.0",
            method: "evm_increaseTime",
            params: [60 * 60 * 24 * 14],
            id: new Date().getTime()
        }, (error, result) => error ? reject(error) : resolve(result.result))
        );
    });

    it('Запускаем CrowdSale от собственника через 15 дней...', async () => {
        try {
            await contract.methods.startCrowdSale().send({
                from: accounts[5],
                gas: "1000000"
            });
            assert(true);    
        } catch (error) {
            assert(false);
        }
    });

    it('Переводим 20 эфиров на контракт - должен принять...', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[9],
                    value: 20*10**18,
                    gas: '1000000'
                });
            assert(true);
        } catch (error) {
            assert(false);
            console.log(error);
        }
    });

    it('Проверка баланса контракта - должно быть 200 эфиров...', async () => {
        let cBalance = web3.utils.fromWei(await contract.methods.getBalance().call(), 'ether');
        assert(cBalance == 200);
        //console.log("Balance of contract", cBalance);
    });

    it('Проверка проданных токенов - должгл быть 1140тыс. (100 эфиров * 5000 + 20%  +   80 * 5000 + 10%  + 20 * 5000  = 1140) ...', async () => {
        let tokenBalance = await contract.methods.soldTokens().call();
        assert(tokenBalance == 1140000 * (10 ** 18));
        //console.log(tokenBalance);
    });

    it('Проверка токенов на счете контракта - должно быть 398 860 000...', async () => {
        let tokenBalance = await contract.methods.getBalanceTokens(contract.options.address).call();
        assert(tokenBalance == 398860000 * (10**18));
        //console.log(tokenBalance);
    });

    it('Возвращаем токены с дополнительного адреса...', async () => {
        try {
            await contract.methods.returnTokensFromHoldAdditionalAddress(1000000000 / 100 * 8).send({
                from: accounts[5],
                gas: '1000000'
            });
            assert(true);    
        } catch (error) {
            assert(false);
        }
    });

    it('Проверка токенов на счете контракта - должно быть 478 860 000...', async () => {
        let tokenBalance = await contract.methods.getBalanceTokens(contract.options.address).call();
        assert(tokenBalance == 478860000 * (10**18));
        //console.log(tokenBalance);
    });    

    it('Возвращаем токены с адреса адвизоров - должен отбить, слишком рано...', async () => {
        try {
            await contract.methods.returnTokensFromHoldAdvisorsAddress(1000000000 / 100).send({
                from: accounts[5],
                gas: '1000000'
            });
            assert(false);    
        } catch (error) {
            assert(error);
        }
    });

    // увеличиваем время в ganache-cli на 15 дней
    it('increase time for 15 days', async () => {
        const myVal = await new Promise((resolve, reject) =>
        web3.currentProvider.sendAsync({
            jsonrpc: "2.0",
            method: "evm_increaseTime",
            params: [60 * 60 * 24 * 15],
            id: new Date().getTime()
        }, (error, result) => error ? reject(error) : resolve(result.result))
        );
    });

    it('Возвращаем токены с адреса адвизоров - должен вернуть...', async () => {
        try {
            await contract.methods.returnTokensFromHoldAdvisorsAddress(1000000000 / 100).send({
                from: accounts[5],
                gas: '1000000'
            });
            assert(true);    
        } catch (error) {
            assert(false);
        }
    });

    it('Проверка токенов на счете контракта - должно быть 488 860 000...', async () => {
        let tokenBalance = await contract.methods.getBalanceTokens(contract.options.address).call();
        assert(tokenBalance == 488860000 * (10**18));
        //console.log(tokenBalance);
    });  

    it('Возвращаем токены с адреса баунти - должен вернуть...', async () => {
        try {
            await contract.methods.returnTokensFromHoldBountyAddress(1000000000 / 100).send({
                from: accounts[5],
                gas: '1000000'
            });
            assert(true);    
        } catch (error) {
            assert(false);
        }
    });


    it('Проверка токенов на счете контракта - должно быть 498 860 000...', async () => {
        let tokenBalance = await contract.methods.getBalanceTokens(contract.options.address).call();
        assert(tokenBalance == 498860000 * (10**18));
        //console.log(tokenBalance);
    });


    it('Возвращаем токены с адреса проекта - должен отбить, слишком рано...', async () => {
        try {
            await contract.methods.returnTokensFromHoldProgectAddress(1000000000 / 2).send({
                from: accounts[5],
                gas: '1000000'
            });
            assert(false);    
        } catch (error) {
            assert(error);
        }
    });

    // увеличиваем время в ganache-cli на 324 дня
    it('increase time for 324 days', async () => {
        const myVal = await new Promise((resolve, reject) =>
        web3.currentProvider.sendAsync({
            jsonrpc: "2.0",
            method: "evm_increaseTime",
            params: [60 * 60 * 24 * 324],
            id: new Date().getTime()
        }, (error, result) => error ? reject(error) : resolve(result.result))
        );
    });

    it('Возвращаем токены с адреса проекта - должен отбить, слишком рано...', async () => {
        try {
            await contract.methods.returnTokensFromHoldProgectAddress(1000000000 / 2).send({
                from: accounts[5],
                gas: '1000000'
            });
            assert(false);    
        } catch (error) {
            assert(error);
        }
    });

    it('increase time for 1 days', async () => {
        const myVal = await new Promise((resolve, reject) =>
        web3.currentProvider.sendAsync({
            jsonrpc: "2.0",
            method: "evm_increaseTime",
            params: [60 * 60 * 24 * 1],
            id: new Date().getTime()
        }, (error, result) => error ? reject(error) : resolve(result.result))
        );
    });

    it('Возвращаем токены с адреса проекта - должен вернуть (прошло 365 дней)...', async () => {
        try {
            await contract.methods.returnTokensFromHoldProgectAddress(1000000000 / 2).send({
                from: accounts[5],
                gas: '1000000'
            });
            assert(true);    
        } catch (error) {
            assert(false);
        }
    });

    it('Проверка токенов на счете контракта - должно быть 998 860 000...', async () => {
        let tokenBalance = await contract.methods.getBalanceTokens(contract.options.address).call();
        assert(tokenBalance == 998860000 * (10**18));
        //console.log(tokenBalance);
    });


    it('Переводим 79 эфиров на контракт...', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[5],
                    value: 79*10**18,
                    gas: '1000000'
                });
            assert(true);
        } catch (error) {
            assert(false);
            console.log(error);
        }
    });

    it('Переводим еще 79 эфиров на контракт...', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[9],
                    value: 79*10**18,
                    gas: '1000000'
                });
            assert(true);
        } catch (error) {
            assert(false);
            console.log(error);
        }
    });
    it('Переводим еще 99 эфиров на контракт...', async () => {
        try {
            let funders = await contract.methods.AddBalanceContract().send({
                    from: accounts[8],
                    value: 99*10**18,
                    gas: '1000000'
                });
            assert(true);
        } catch (error) {
            assert(false);
            console.log(error);
        }
    });

    it('Сумма проданных токенов больше софткап ...', async () => {
        let tokenBalance = await contract.methods.soldTokens().call();
        assert(tokenBalance > 2000000 * (10 ** 18));
        //console.log(tokenBalance);
    });

    it('Завершаем CrowdSale от собственника...', async () => {
        try {
            await contract.methods.finishCrowdSale().send({
                from: accounts[5],
                gas: "1000000"
            });
            assert(true);    
        } catch (error) {
            assert(false);
        }
    });

    it('Получаем стадию контракта, должен быть WorkTime, т.к SoftCap набран...', async () => {
        const myState = await contract.methods.currentState().call({
            from: accounts[8],
            gas: "1000000"
        });
        assert(myState == 5 );
        //console.log(myState);
    });

    
    it('Проверка баланса контракта - должно быть 457 эфиров...', async () => {
        let cBalance = web3.utils.fromWei(await contract.methods.getBalance().call(), 'ether');
        assert(cBalance == 457);
        //console.log("Balance of contract", cBalance);
    });

    it('Возвращаем средства на account[7] - должен отбить, т.к. refund не работает...', async () => {
        try {
            await contract.methods.refund().send({
                from: accounts[7],
                gas: "1000000"
            });
            assert(false);    
        } catch (error) {
            assert(error);
        }
    });

    it('Проверка баланса на accounts[6] перед выводом средств...', async () => {
        accBalance = await web3.eth.getBalance(accounts[6]);
        assert(accBalance > 0);
        console.log("Balance of accounts[6]: ", accBalance / (10**18));
    });

    it('Переводим средства с контракта (450 эфиров) на account[6] от посторонней учетки - должен отбить ...', async () => {
        try {
            await contract.methods.withdrawProfit(accounts[6], 450 * 10 ** 18 ).send({
                from: accounts[6],
                gas: "1000000"
            });
            assert(false);    
        } catch (error) {
            assert(error);
        }
    });

    it('Переводим средства с контракта (450 эфиров) на account[6] от собственника ...', async () => {
        try {
            await contract.methods.withdrawProfit(accounts[6], 450 * 10 ** 18 ).send({
                from: accounts[5],
                gas: "1000000"
            });
            assert(true);    
        } catch (error) {
            assert(false);
        }
    });

    it('Проверка баланса контракта - должно быть 7 эфиров...', async () => {
        let cBalance = web3.utils.fromWei(await contract.methods.getBalance().call(), 'ether');
        assert(cBalance == 7);
        //console.log("Balance of contract", cBalance);
    });

    it('Проверка баланса на accounts[6] - более 450 эфиров...', async () => {
        accBalance = await web3.eth.getBalance(accounts[6]);
        assert(accBalance > 450);
        console.log("Balance of accounts[6]: ", accBalance / (10**18));
    });

});
